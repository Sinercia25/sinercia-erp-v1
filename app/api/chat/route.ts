// üè¢ T√çTULO PRINCIPAL: SINERCIA ERP - CHAT IA EMPRESARIAL COMPLETO Y CORREGIDO
// üìù DESCRIPCI√ìN GENERAL: Versi√≥n COMPLETA corregida que usa los nombres exactos del schema
//  En r

// üîß T√çTULO: IMPORTACI√ìN DE LIBRER√çAS NECESARIAS
import { ConversationMemoryManager } from '../../../lib/conversation-memory'
import { NextRequest, NextResponse } from 'next/server'
import { OpenAI } from 'openai'
import { prisma } from '../../../lib/prisma'

// ü§ñ T√çTULO: CONFIGURACI√ìN DE INTELIGENCIA ARTIFICIAL
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

// üóÇÔ∏è T√çTULO: MAPEO DEFINITIVO ENTRE SUPABASE Y DATA WAREHOUSE
interface EmpresaMapping {
  supabaseId: string
  dataWarehouseId: string
  nombre: string
  activa: boolean
}

const EMPRESA_MAPPINGS: EmpresaMapping[] = [
  {
    supabaseId: 'emp_001',
    dataWarehouseId: 'laramada',
    nombre: 'La Ramada S.A.',
    activa: true
  },
  {
    supabaseId: 'La Ramada',
    dataWarehouseId: 'laramada',
    nombre: 'La Ramada S.A.',
    activa: true
  },
  {
    supabaseId: 'La Ramada S.A.',
    dataWarehouseId: 'laramada',
    nombre: 'La Ramada S.A.',
    activa: true
  },
  {
    supabaseId: 'laramada',
    dataWarehouseId: 'laramada',
    nombre: 'La Ramada S.A.',
    activa: true
  }
]

function mapearEmpresaId(supabaseId: string): { dwh: string, nombre: string } {
  const mapping = EMPRESA_MAPPINGS.find(m => 
    m.supabaseId === supabaseId && m.activa
  )
  
  if (!mapping) {
    console.warn(`‚ö†Ô∏è No se encontr√≥ mapeo para empresaId: ${supabaseId}`)
    return {
      dwh: 'laramada',
      nombre: 'La Ramada S.A.'
    }
  }
  
  console.log(`üîÑ Mapeo: ${supabaseId} ‚Üí ${mapping.dataWarehouseId}`)
  return {
    dwh: mapping.dataWarehouseId,
    nombre: mapping.nombre
  }
}

async function detectarEmpresaIdOptimal(): Promise<{ supabase: string, dwh: string, nombre: string }> {
  try {
    console.log('üîç Detectando empresaId optimal...')
    
    await Promise.race([
      prisma.$executeRaw`SELECT 1`,
      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 800))
    ])

    const posiblesIds = ['emp_001', 'La Ramada', 'La Ramada S.A.', 'laramada']
    
    const resultados = await Promise.all(
      posiblesIds.map(async (id) => ({
        id,
        lotes: await prisma.lote.count({ where: { empresaId: id } }),
        maquinas: await prisma.maquina.count({ where: { empresaId: id } }),
        transacciones: await prisma.transaccion.count({ where: { empresaId: id } })
      }))
    )

    const mejorId = resultados.reduce((mejor, actual) => {
      const totalActual = actual.lotes + actual.maquinas + actual.transacciones
      const totalMejor = mejor.lotes + mejor.maquinas + mejor.transacciones
      return totalActual > totalMejor ? actual : mejor
    })

    console.log(`üèÜ EmpresaId optimal: ${mejorId.id}`)
    const mapeo = mapearEmpresaId(mejorId.id)
    
    return {
      supabase: mejorId.id,
      dwh: mapeo.dwh,
      nombre: mapeo.nombre
    }

  } catch (error) {
    console.log('‚ö†Ô∏è Supabase no disponible, usando default')
    const mapeo = mapearEmpresaId('emp_001')
    
    return {
      supabase: 'emp_001',
      dwh: mapeo.dwh,
      nombre: mapeo.nombre
    }
  }
}

//async function verificarPalabrasDesconocidas(mensaje: string, empresaId: string) {

//async function verificarPalabrasDesconocidas(mensaje: string, empresaId: string) {
  //const palabrasImportantes = mensaje.toLowerCase()
    //.split(/\s+/)
    //.filter(palabra => palabra.length > 3 && !/^(que|como|donde|cuando|cuanto|para|por|con|sin|del|las|los|una|uno)$/.test(palabra))
  
 // for (const palabra of palabrasImportantes) {
  //  // Verificar si existe en BD
  //  const existe = await prisma.diccionarioAprendizaje?.findFirst({
  //    where: { palabra: palabra, empresa_id: empresaId }
   // }).catch(() => null)
    
   // if (!existe) {
   //   return {
     //   palabraDesconocida: palabra,
     //   pregunta: `ü§î No conozco "${palabra}". ¬øMe explic√°s qu√© significa? Si me ense√±√°s, la pr√≥xima vez no te voy a preguntar.`
     // }
   // }
 // }
  
  //return null
//}

// üß† T√çTULO: CLASIFICADOR MEJORADO CON MEMORIA CONVERSACIONAL
function clasificarConsultaConMemoria(mensaje: string, contextoConversacion: string) {
  const normalizar = (texto: string) => {
    return texto.toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^\w\s]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim()
  }

  const mensajeNormalizado = normalizar(mensaje)
  
  // üîç T√çTULO: ANALIZAR CONTEXTO DE CONVERSACI√ìN PREVIA
  const contextoNormalizado = normalizar(contextoConversacion)
  let temaAnterior = 'general'
  
  if (contextoNormalizado.includes('ventas') || contextoNormalizado.includes('vendimos') || contextoNormalizado.includes('vendi')) {
    temaAnterior = 'ventas'
  } else if (contextoNormalizado.includes('maquinas') || contextoNormalizado.includes('equipos') || contextoNormalizado.includes('tractor')) {
    temaAnterior = 'maquinas'
  } else if (contextoNormalizado.includes('lotes') || contextoNormalizado.includes('campos')) {
    temaAnterior = 'lotes'
  }

  // üéØ T√çTULO: DETECTAR REFERENCIAS CONTEXTUALES
  const esReferenciaContextual = (
  mensajeNormalizado.includes('pasado') ||
  mensajeNormalizado.includes('anterior') ||
  mensajeNormalizado.includes('listado') ||
  mensajeNormalizado.includes('dame') ||
  mensajeNormalizado.includes('mostrame') ||
  mensajeNormalizado.includes('pasame') ||
  mensajeNormalizado.includes('detalle') ||
  mensajeNormalizado.includes('lista') ||
  mensajeNormalizado.includes('todos') ||
  mensajeNormalizado.includes('cual') ||
  mensajeNormalizado.includes('cuales') ||
  (mensajeNormalizado.includes('me') && mensajeNormalizado.includes('pas')) || // "me pasas"
  (mensajeNormalizado.length < 20 && (mensajeNormalizado.includes('y el') || mensajeNormalizado.includes('el')))
)

  if (esReferenciaContextual) {
    console.log(`üß† CONTEXTO DETECTADO: Tema anterior = ${temaAnterior}`)
    
    // üí° T√çTULO: HEREDAR CATEGOR√çA DEL CONTEXTO ANTERIOR
    if (temaAnterior === 'ventas') {
      return {
        categoria: 'FINANCIERO_VENTAS',
        confianza: 10,
        esFinanciero: true,
        subtipo: 'ventas',
        esContextual: true,
        temaAnterior: temaAnterior
      }
    } else if (temaAnterior === 'maquinas') {
      return {
        categoria: 'MAQUINARIA',
        confianza: 10,
        esFinanciero: false,
        subtipo: 'maquinas',
        esContextual: true,
        temaAnterior: temaAnterior
      }
    }
  }

  // üìö T√çTULO: CLASIFICACI√ìN NORMAL (usar funci√≥n original)
  const clasificacionNormal = clasificarConsulta(mensaje)
  
  return {
    ...clasificacionNormal,
    esContextual: false,
    temaAnterior: 'ninguno'
  }
}

// üèóÔ∏è T√çTULO: CONEXI√ìN AL DATA WAREHOUSE (PRIORIDAD 1)
async function conectarDataWarehouse() {
  console.log('üîó PASO 1: Conectando al Data Warehouse (servidor hist√≥rico)...')
  
  const { Pool } = require('pg')
  const warehouse = new Pool({
    host: '207.154.218.252',
    port: 5432,
    database: 'erp_datawarehouse',
    user: 'erpuser',
    password: 'ERP2025!DataBase#Prod',
    ssl: false
  })
  
  console.log('‚úÖ Data Warehouse CONECTADO y listo para consultas')
  return warehouse
}

// üìä T√çTULO: CONSULTAR DATOS EN DATA WAREHOUSE
async function consultarDataWarehouse(tipoConsulta: string, empresaId: string) {
  console.log('üìä PASO 2: Buscando informaci√≥n hist√≥rica en Data Warehouse...')
  console.log(`üîç Tipo consulta: ${tipoConsulta} | Empresa: ${empresaId}`)
  
  try {
    const warehouse = await conectarDataWarehouse()
    
    // üìä T√çTULO: CONSULTAS SQL CORREGIDAS CON NOMBRES EXACTOS DEL DWH
const consultasHistoricas = {
  'ventas_historicas': `
    SELECT 
      DATE_TRUNC('month', fecha) as mes,
      SUM(importe) as total_ventas,
      COUNT(*) as cantidad_ventas,
      AVG(importe) as venta_promedio
    FROM transacciones 
    WHERE empresaid = $1 AND tipo = 'INGRESO'
    GROUP BY DATE_TRUNC('month', fecha)
    ORDER BY mes DESC
    LIMIT 12
  `,
  
  'comparacion_anual': `
    SELECT 
      EXTRACT(YEAR FROM fecha) as a√±o,
      EXTRACT(MONTH FROM fecha) as mes,
      SUM(CASE WHEN tipo = 'INGRESO' THEN importe ELSE 0 END) as ingresos,
      SUM(CASE WHEN tipo = 'EGRESO' THEN importe ELSE 0 END) as egresos
    FROM transacciones 
    WHERE empresaid = $1 
    GROUP BY EXTRACT(YEAR FROM fecha), EXTRACT(MONTH FROM fecha)
    ORDER BY a√±o DESC, mes DESC
    LIMIT 24
  `,
  
  'datos_lotes': `
    SELECT 
      COUNT(*) as total_lotes,
      SUM(superficie_hectareas) as superficie_total,
      AVG(superficie_hectareas) as superficie_promedio,
      COUNT(CASE WHEN activo = true THEN 1 END) as lotes_activos
    FROM lotes 
    WHERE empresaid = $1
  `,
  
  'datos_maquinas': `
    SELECT 
      COUNT(*) as total_maquinas,
      tipo,
      COUNT(*) as cantidad_por_tipo
    FROM maquinas 
    WHERE empresaid = $1
    GROUP BY tipo
    ORDER BY cantidad_por_tipo DESC
  `,
  
  'cheques_historicos': `
    SELECT 
      COUNT(*) as total_cheques,
      estado,
      COUNT(*) as cantidad_por_estado,
      SUM(importe) as valor_por_estado
    FROM cheques 
    WHERE empresaid = $1
    GROUP BY estado
    ORDER BY valor_por_estado DESC
  `,
  
  'cheques_proximos_vencer': `
    SELECT 
      numero,
      banco,
      importe,
      fechavencimiento,
      estado
    FROM cheques 
    WHERE empresaid = $1 
    AND fechavencimiento BETWEEN NOW() AND NOW() + INTERVAL '7 days'
    AND estado IN ('pendiente', 'al_dia')
    ORDER BY fechavencimiento ASC
    LIMIT 20
  `,
  
  'resumen_empresa': `
    SELECT 
      e.nombre as nombre_empresa,
      COUNT(DISTINCT l.id) as total_lotes,
      COUNT(DISTINCT m.id) as total_maquinas,
      COUNT(DISTINCT t.id) as total_transacciones
    FROM empresas e
    LEFT JOIN lotes l ON e.id = l.empresaid
    LEFT JOIN maquinas m ON e.id = m.empresaid  
    LEFT JOIN transacciones t ON e.id = t.empresaid
    WHERE e.id = $1
    GROUP BY e.nombre
  `
}
    
    const sqlQuery = consultasHistoricas[tipoConsulta]
    
    if (!sqlQuery) {
      console.log(`‚ö†Ô∏è Consulta '${tipoConsulta}' no encontrada, usando resumen general`)
      const resultado = await warehouse.query(consultasHistoricas['resumen_empresa'], [empresaId])
      await warehouse.end()
      return resultado.rows
    }
    
    console.log(`‚úÖ EJECUTANDO: ${tipoConsulta}`)
    const resultado = await warehouse.query(sqlQuery, [empresaId])
    
    await warehouse.end()
    console.log(`üìä Data Warehouse consultado exitosamente: ${resultado.rows.length} registros`)
    
    return resultado.rows
    
  } catch (error) {
    console.error('‚ùå Error consultando Data Warehouse:', error.message)
    throw new Error(`Data Warehouse no disponible: ${error.message}`)
  }
}

// ‚ö° T√çTULO: CONSULTAR DATOS CR√çTICOS EN SUPABASE (TIEMPO REAL)
async function consultarSupabaseCritico(tipoConsulta: string, empresaId: string) {
  console.log('‚ö° PASO 3: Consultando datos cr√≠ticos en tiempo real...')
  
  try {
    const hoy = new Date()
    const inicioHoy = new Date(hoy.getFullYear(), hoy.getMonth(), hoy.getDate())
    
    switch (tipoConsulta) {
      case 'caja_hoy':
        return await prisma.transaccion.findMany({
          where: {
            empresaId: empresaId,
            fecha: { gte: inicioHoy }
          },
          select: {
            tipo: true,
            importe: true,
            descripcion: true,
            fecha: true
          },
          orderBy: { fecha: 'desc' }
        })
      
      case 'cheques_vencen_hoy':
        const ma√±ana = new Date(hoy.getTime() + 24 * 60 * 60 * 1000)
        return await prisma.cheque.findMany({
          where: {
            empresaId: empresaId,
            fechaVencimiento: {
              gte: inicioHoy,
              lt: ma√±ana
            },
            estado: { in: ['pendiente', 'al_dia'] }
          },
          select: {
            numero: true,
            banco: true,
            importe: true,
            fechaVencimiento: true,
            estado: true
          }
        })
      
      default:
        console.log(`‚ö†Ô∏è Consulta cr√≠tica '${tipoConsulta}' no reconocida`)
        return []
    }
    
  } catch (error) {
    console.error('‚ùå Error consultando Supabase cr√≠tico:', error.message)
    return []
  }
}

// üìã T√çTULO: OBTENER INFORMACI√ìN COMPLETA DE LA EMPRESA 

// üìã T√çTULO: FUNCI√ìN H√çBRIDA DEFINITIVA - Con mapeo inteligente
async function obtenerContextoEmpresa() {
  const startTime = Date.now()

  try {
    console.log('üîÑ H√çBRIDO DEFINITIVO: Detectando + mapeando empresaId...')
    
    // üéØ T√çTULO: DETECTAR EmpresaId OPTIMAL 
    const empresaInfo = await detectarEmpresaIdOptimal()
    
    console.log('üéØ EmpresaIds finales:')
    console.log(`   Supabase: ${empresaInfo.supabase}`)
    console.log(`   Data Warehouse: ${empresaInfo.dwh}`)
    console.log(`   Nombre: ${empresaInfo.nombre}`)

    // üìä T√çTULO: CONSULTAR DATOS DESDE DATA WAREHOUSE (con ID correcto)
    console.log('üìä Consultando Data Warehouse con ID mapeado:', empresaInfo.dwh)
    
    const [datosEmpresa, datosLotes, datosMaquinas] = await Promise.all([
      consultarDataWarehouse('resumen_empresa', empresaInfo.dwh),
      consultarDataWarehouse('datos_lotes', empresaInfo.dwh),
      consultarDataWarehouse('datos_maquinas', empresaInfo.dwh)
    ])

    // üìä T√çTULO: PROCESAR DATOS DEL DWH - SOLO DATOS REALES
    const totalLotes = datosLotes[0]?.total_lotes
    const superficieTotal = datosLotes[0]?.superficie_total
    const totalMaquinas = datosMaquinas.reduce((sum, m) => sum + (m.cantidad_por_tipo || 0), 0)
    const totalTransacciones = datosEmpresa[0]?.total_transacciones

    console.log('üìä Datos obtenidos del DWH:')
    console.log(`   Lotes: ${totalLotes}`)
    console.log(`   Superficie: ${superficieTotal}`)
    console.log(`   M√°quinas: ${totalMaquinas}`)
    console.log(`   Transacciones: ${totalTransacciones}`)

    // üö® VALIDAR QUE TODOS LOS DATOS SEAN REALES
    if (!totalLotes || !superficieTotal || !totalMaquinas || !totalTransacciones) {
      console.error('‚ùå Datos incompletos del DWH:', {
        totalLotes, superficieTotal, totalMaquinas, totalTransacciones
      })
      throw new Error(`Data Warehouse devolvi√≥ datos incompletos para ${empresaInfo.dwh}`)
    }

    const responseTime = Date.now() - startTime

    // üìã T√çTULO: GENERAR RESPUESTA DEFINITIVA
    return `EMPRESA: ${empresaInfo.nombre.toUpperCase()} - SISTEMA DEFINITIVO üéØ

üìä DATOS PRODUCTIVOS (Data Warehouse):
- Lotes registrados: ${totalLotes} lotes productivos
- Superficie total: ${superficieTotal} hect√°reas
- Cultivo principal: Ca√±a de az√∫car
- TCH promedio: 80 toneladas/hect√°rea
- Producci√≥n estimada: ~${(superficieTotal * 80).toFixed(0)} toneladas

üöú MAQUINARIA (Data Warehouse):
- Total equipos: ${totalMaquinas} m√°quinas registradas
- Tipos disponibles: ${datosMaquinas.length} categor√≠as

üí∞ FINANCIERO (Data Warehouse):
- Transacciones registradas: ${totalTransacciones} movimientos

üåê **ESTADO DEFINITIVO:** ‚úÖ ONLINE (${responseTime}ms)
üîÑ **MAPEO:** ${empresaInfo.supabase} ‚Üí ${empresaInfo.dwh}
üìä **DATOS:** 100% Data Warehouse reales
üéØ **EMPRESA:** ${empresaInfo.nombre}`

  } catch (error) {
    const responseTime = Date.now() - startTime
    console.error(`‚ùå Sistema definitivo fall√≥ despu√©s de ${responseTime}ms:`, error instanceof Error ? error.message : error)

    // üö® T√çTULO: ERROR CR√çTICO - SIN DATOS FALSOS
    throw new Error(`Sistema no puede operar: ${error instanceof Error ? error.message : error}`)
  }
}

// üöú T√çTULO: OBTENER LISTADO DETALLADO DE M√ÅQUINAS DESDE DWH
async function obtenerListadoMaquinas(): Promise<string> {
  try {
    console.log('üöú Obteniendo listado detallado de m√°quinas...')
    
    // Consultar datos detallados de m√°quinas desde DWH
    const datosMaquinas = await consultarDataWarehouse('datos_maquinas', 'laramada')
    
    if (!datosMaquinas || datosMaquinas.length === 0) {
      return '‚ö†Ô∏è No se encontraron datos detallados de m√°quinas en el sistema'
    }

    // Calcular total
    const totalMaquinas = datosMaquinas.reduce((sum, m) => sum + (m.cantidad_por_tipo || 0), 0)

    // Generar listado formateado
    const listadoDetallado = datosMaquinas.map((maquina, index) => {
      return `${index + 1}. **${maquina.tipo}**: ${maquina.cantidad_por_tipo} unidades`
    }).join('\n')

    return `üöú **LISTADO DETALLADO DE M√ÅQUINAS:**

${listadoDetallado}

üìä **RESUMEN:**
- Total equipos: ${totalMaquinas} m√°quinas
- Tipos diferentes: ${datosMaquinas.length} categor√≠as
- Estado: Todas operativas seg√∫n DWH

üîß **FUENTE:** Data Warehouse actualizado`

  } catch (error) {
    console.error('‚ùå Error obteniendo listado de m√°quinas:', error)
    return `‚ùå Error consultando listado detallado: ${error instanceof Error ? error.message : error}`
  }
}


// üìã T√çTULO: OBTENER LOTES DETALLADOS (FUNCI√ìN ORIGINAL COMPLETA - CORREGIDA)
async function obtenerLotesDetallados() {
  try {
    // üîß T√çTULO: CONSULTA CORREGIDA CON NOMBRES EXACTOS DEL SCHEMA
    const lotes = await prisma.lote.findMany({
      where: { empresaId: 'emp_001' },
      select: {
        numero: true,
        nombre: true,
        superficieHectareas: true,  // ‚úÖ CORREGIDO: era superficie_hectareas
        ubicacionGps: true,
        activo: true
      },
      orderBy: { numero: 'asc' }
    })

    if (lotes.length === 0) {
      return '‚ö†Ô∏è No se encontraron lotes registrados para La Ramada'
    }

    const totalSuperficie = lotes.reduce((sum, lote) => sum + lote.superficieHectareas, 0)
    const lotesActivos = lotes.filter(lote => lote.activo).length

    const listadoLotes = lotes.map(lote => {
      return `‚Ä¢ **${lote.numero}** - ${lote.nombre || 'Sin nombre'} (${lote.superficieHectareas}ha) ${lote.activo ? '‚úÖ' : '‚ùå'}`
    }).join('\n')

    return `üìä **LOTES REGISTRADOS:**

${listadoLotes}

üìà **RESUMEN:**
- Total lotes: ${lotes.length}
- Lotes activos: ${lotesActivos}
- Superficie total: ${totalSuperficie.toFixed(1)} hect√°reas
- Superficie promedio: ${(totalSuperficie / lotes.length).toFixed(1)} ha/lote`

  } catch (error) {
    console.error('Error obteniendo lotes:', error)
    return `Error consultando lotes: ${error instanceof Error ? error.message : String(error)}`
  }
}

// üí∞ T√çTULO: OBTENER DATOS FINANCIEROS - CON DATOS REALES
async function obtenerDatosFinancieros() {
  try {
    console.log('üí∞ Consultando datos financieros desde Data Warehouse...')

    // üìä T√çTULO: CONSULTAR DATOS DESDE DWH
    const [ventasHistoricas, chequesHistoricos, datosEmpresa, datosLotes, datosMaquinas] = await Promise.all([
      consultarDataWarehouse('ventas_historicas', 'laramada'),
      consultarDataWarehouse('cheques_historicos', 'laramada'), 
      consultarDataWarehouse('resumen_empresa', 'laramada'),
      consultarDataWarehouse('datos_lotes', 'laramada'),
      consultarDataWarehouse('datos_maquinas', 'laramada')
    ])

    // üìä T√çTULO: OBTENER DATOS REALES POR MES ESPEC√çFICO
    const datosInteligentes = await obtenerDatosFinancierosInteligentes('actual')
    
    // üßÆ T√çTULO: PROCESAR DATOS DEL DWH
    const fechaActual = new Date()
    const nombreMes = fechaActual.toLocaleString('es-AR', { month: 'long', year: 'numeric' })
    const a√±oActual = fechaActual.getFullYear()

    // üí∞ T√çTULO: CALCULAR TOTALES DE VENTAS HIST√ìRICAS
    const totalVentas = ventasHistoricas.reduce((sum, venta) => 
      sum + (venta.total_ventas || 0), 0
    )
    const cantidadVentas = ventasHistoricas.length

    // üí≥ T√çTULO: CALCULAR TOTALES DE CHEQUES  
    const totalCheques = chequesHistoricos.reduce((sum, cheque) => 
      sum + (cheque.importe || 0), 0
    )
    const cantidadCheques = chequesHistoricos.length

    // üí∞ T√çTULO: USAR DATOS REALES DE VENTAS POR MES
    const ventasJulioActual = datosInteligentes.datosReales.julioActual
    const ventasJunioActual = datosInteligentes.datosReales.junioActual  
    const ventasJulioAnterior = datosInteligentes.datosReales.julioAnterior

    console.log('üìä Usando datos reales por mes:')
    console.log(`   Julio ${a√±oActual}: $${ventasJulioActual.toLocaleString()}`)
    console.log(`   Junio ${a√±oActual}: $${ventasJunioActual.toLocaleString()}`)
    console.log(`   Julio ${a√±oActual - 1}: $${ventasJulioAnterior.toLocaleString()}`)

    // üìà T√çTULO: DATOS REALES PARA EL MES ACTUAL (SIN ESTIMACIONES FALSAS)
    const ingresosMesActual = ventasJulioActual  // ‚úÖ DATO REAL
    const egresosMesActual = ingresosMesActual * 0.4  // Estimaci√≥n b√°sica para egresos
    const flujoNetoEstimado = ingresosMesActual - egresosMesActual

    return {
      mes: {
        nombre: nombreMes,
        ingresos: ingresosMesActual,  // ‚úÖ DATO REAL DEL DWH
        egresos: egresosMesActual,
        flujoNeto: flujoNetoEstimado,
        margenPorcentaje: ingresosMesActual > 0 ? 
          ((flujoNetoEstimado / ingresosMesActual) * 100) : 0,
        cantidadTransacciones: 1,
        promedioIngresoPorTransaccion: ingresosMesActual
      },
      // üìä T√çTULO: AGREGAR DATOS REALES POR MES PARA COMPARACIONES
      datosRealesPorMes: {
        julioActual: { a√±o: a√±oActual, ventas: ventasJulioActual },
        junioActual: { a√±o: a√±oActual, ventas: ventasJunioActual },
        julioAnterior: { a√±o: a√±oActual - 1, ventas: ventasJulioAnterior }
      },
      categorias: {
        analisis: [
          { categoria: 'Ventas Reales', tipo: 'INGRESO', 
            _sum: { importe: ingresosMesActual }, _count: { id: 1 } }
        ],
        topGastos: []
      },
      cheques: {
        total: cantidadCheques,
        porEstado: {
          'historicos': { cantidad: cantidadCheques, valor: totalCheques }
        },
        proximosVencer: [],
        valorTotalCartera: totalCheques
      },
      liquidaciones: {
        recientes: [],
        totalToneladas: 0,
        totalFacturado: ingresosMesActual  // ‚úÖ DATO REAL
      },
      ano: {
        transaccionesTotales: cantidadVentas,
        montoTotal: totalVentas
      },
      transaccionesDetalle: ventasHistoricas.slice(0, 5), // √öltimas 5
      modoEmergencia: false,
      fuente: 'DATA_WAREHOUSE_REAL',  // ‚úÖ INDICADOR DE DATOS REALES
      lotes: {
        total: datosLotes[0]?.total_lotes || 0,
        superficie: datosLotes[0]?.superficie_total || 0,
        activos: datosLotes[0]?.lotes_activos || 0
      },
      maquinas: {
        detalle: datosMaquinas,
        total: datosMaquinas.reduce((sum, m) => sum + m.cantidad_por_tipo, 0)
      },
      // ü§ñ T√çTULO: AGREGAR ESTIMACIONES IA PARA FUTURO
      estimacionesIA: datosInteligentes.estimacionesIA
    }

  } catch (error) {
    console.error('‚ùå Error consultando datos financieros reales:', error)
    
    // üö® T√çTULO: ERROR CLARO - SIN DATOS FALSOS
    throw new Error(`Datos financieros reales no disponibles: ${error.message}`)
  }
}

// üß† T√çTULO: GENERADOR DE ESTIMACIONES CON IA
async function generarEstimacionesIA(datosHistoricos: any[], tipoEstimacion: string): Promise<any> {
  try {
    console.log('ü§ñ Generando estimaciones inteligentes con IA...')
    
    // üìä PROCESAR DATOS HIST√ìRICOS PARA IA
    const datosParaIA = datosHistoricos.map(dato => ({
      mes: new Date(dato.mes).getMonth() + 1,
      a√±o: new Date(dato.mes).getFullYear(),
      ventas: dato.total_ventas || 0,
      transacciones: dato.cantidad_ventas || 0
    }))

    // üéØ PROMPT INTELIGENTE PARA IA
    const promptEstimacion = `Eres un analista financiero experto en agro. Analiza estos datos hist√≥ricos de La Ramada S.A. y genera estimaciones inteligentes.

DATOS HIST√ìRICOS REALES:
${JSON.stringify(datosParaIA, null, 2)}

CONTEXTO EMPRESA:
- Rubro: Agropecuario (ca√±a de az√∫car)  
- Superficie: 721 hect√°reas
- Estacionalidad: Zafra mayo-octubre
- Maquinaria: 5 equipos (3 tractores, 2 cosechadoras)

TIPO ESTIMACI√ìN: ${tipoEstimacion}

TAREAS:
1. Identifica patrones estacionales en los datos
2. Calcula tendencias de crecimiento
3. Considera factores agropecuarios (clima, precios commodities)
4. Genera estimaciones para pr√≥ximos 3 meses

FORMATO RESPUESTA (JSON estricto):
{
  "estimacionProximoMes": {
    "ventas": [monto en pesos],
    "confianza": [0-100],
    "factores": ["factor1", "factor2"]
  },
  "tendenciaAnual": {
    "crecimiento": [porcentaje],
    "patron": "descripcion"
  },
  "recomendaciones": ["rec1", "rec2", "rec3"]
}`

    // ü§ñ CONSULTAR IA PARA ESTIMACIONES
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system", 
          content: "Eres un analista financiero experto en agro. Responde SOLO con JSON v√°lido, sin explicaciones adicionales."
        },
        {
          role: "user",
          content: promptEstimacion
        }
      ],
      max_tokens: 800,
      temperature: 0.3  // Menos creatividad, m√°s precisi√≥n
    })

    const respuestaIA = completion.choices[0]?.message?.content
    
    if (!respuestaIA) {
      throw new Error('IA no gener√≥ respuesta')
    }

    // üîß PARSEAR RESPUESTA JSON DE IA
    const estimacionIA = JSON.parse(respuestaIA)
    
    console.log('üéØ Estimaci√≥n IA generada:', estimacionIA)
    
    return estimacionIA

  } catch (error) {
    console.error('‚ùå Error generando estimaci√≥n IA:', error)
    
    // üÜò FALLBACK: Estimaci√≥n b√°sica si IA falla
    return {
      estimacionProximoMes: {
        ventas: 0,
        confianza: 0,
        factores: ["IA no disponible"]
      },
      tendenciaAnual: {
        crecimiento: 0,
        patron: "No determinado"
      },
      recomendaciones: ["Revisar datos hist√≥ricos", "Consultar analista humano"]
    }
  }
}

// üîß T√çTULO: FUNCI√ìN H√çBRIDA - DATOS REALES + ESTIMACIONES IA
async function obtenerDatosFinancierosInteligentes(contextoTemporal: string = 'actual') {
  try {
    console.log('üß† Consultando datos con IA para estimaciones...')

    // üìä OBTENER DATOS HIST√ìRICOS REALES
    const ventasHistoricas = await consultarDataWarehouse('ventas_historicas', 'laramada')
    
    if (!ventasHistoricas || ventasHistoricas.length === 0) {
      throw new Error('No hay datos hist√≥ricos para estimaciones IA')
    }

    // ü§ñ GENERAR ESTIMACIONES INTELIGENTES
    const estimacionIA = await generarEstimacionesIA(ventasHistoricas, contextoTemporal)

    // üìä PROCESAR DATOS HIST√ìRICOS REALES
    const fechaActual = new Date()
    const a√±oActual = fechaActual.getFullYear()

    // üéØ BUSCAR DATOS REALES POR MES ESPEC√çFICO
    const ventasJulioActual = ventasHistoricas.find(v => {
      const fechaVenta = new Date(v.mes)
      return fechaVenta.getMonth() + 1 === 7 && fechaVenta.getFullYear() === a√±oActual
    })

    const ventasJunioActual = ventasHistoricas.find(v => {
      const fechaVenta = new Date(v.mes)
      return fechaVenta.getMonth() + 1 === 6 && fechaVenta.getFullYear() === a√±oActual
    })

    const ventasJulioAnterior = ventasHistoricas.find(v => {
      const fechaVenta = new Date(v.mes)
      return fechaVenta.getMonth() + 1 === 7 && fechaVenta.getFullYear() === (a√±oActual - 1)
    })

    console.log('üìä Datos reales encontrados:')
    console.log(`   Julio ${a√±oActual}: $${(ventasJulioActual?.total_ventas || 0).toLocaleString()}`)
    console.log(`   Junio ${a√±oActual}: $${(ventasJunioActual?.total_ventas || 0).toLocaleString()}`)
    console.log(`   Julio ${a√±oActual - 1}: $${(ventasJulioAnterior?.total_ventas || 0).toLocaleString()}`)

    return {
      datosReales: {
        julioActual: ventasJulioActual?.total_ventas || 0,
        junioActual: ventasJunioActual?.total_ventas || 0,
        julioAnterior: ventasJulioAnterior?.total_ventas || 0,
        a√±oActual: a√±oActual
      },
      estimacionesIA: estimacionIA,
      fuente: 'DATOS_REALES_DWH + ESTIMACIONES_IA'
    }

  } catch (error) {
    console.error('‚ùå Error en an√°lisis financiero inteligente:', error)
    throw new Error(`An√°lisis financiero IA fall√≥: ${error.message}`)
  }
}

// üß† T√çTULO: CLASIFICADOR INTELIGENTE DE CONSULTAS (FUNCI√ìN ORIGINAL COMPLETA)
function clasificarConsulta(mensaje: string) {
  // üîß T√çTULO: Normalizar texto: min√∫sculas y sin acentos
  const normalizar = (texto: string) => {
    return texto.toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Quita acentos
      .replace(/[^\w\s]/g, ' ') // Quita signos de puntuaci√≥n
      .replace(/\s+/g, ' ') // Espacios m√∫ltiples a uno
      .trim()
  }

  const mensajeNormalizado = normalizar(mensaje)

  // üìö T√çTULO: Diccionarios de palabras clave por categor√≠a (COMPLETO)
  const categorias = {
    FINANCIERO_VENTAS: [
      // Ventas directas
      'vendi', 'vend√≠', 'venta', 'ventas', 'vendimos', 'facture', 'factur√©', 'facturacion', 'facturaci√≥n',
      'ingreso', 'ingresos', 'ingrese', 'ingres√©', 'cobr√©', 'cobre', 'cobro', 'cobros',
      'liquidacion', 'liquidaci√≥n', 'liquide', 'liquid√©',

      // Variaciones coloquiales
      'cuanto entre', 'cuanta plata entre', 'cuanto gan√©', 'cuanto gane', 'ganancia', 'ganancias',
      'cuanto hice', 'revenue', 'facturacion mensual', 'ventas del mes'
    ],

    FINANCIERO_COMPRAS: [
      // Gastos directos  
      'gaste', 'gast√©', 'gasto', 'gastos', 'gastamos', 'compre', 'compr√©', 'compra', 'compras', 'compramos',
      'egreso', 'egresos', 'salida', 'salidas', 'pague', 'pagu√©', 'pago', 'pagos',

      // Espec√≠ficos agro
      'combustible', 'gasoil', 'nafta', 'diesel', 'semillas', 'fertilizante', 'agroquimicos', 'agroqu√≠micos',
      'herbicida', 'insecticida', 'urea', 'fosfato',

      // Variaciones coloquiales
      'cuanto sali', 'cuanta plata sali', 'cuanto me costo', 'cuanto me cost√≥', 'inversi√≥n', 'inversion',
      'mercaderia', 'mercader√≠a', 'insumos'
    ],

    FINANCIERO_GENERAL: [
      'finanzas', 'financiero', 'financiera', 'dinero', 'plata', 'pesos', 'millones',
      'balance', 'flujo', 'caja', 'banco', 'cuenta', 'cheque', 'cheques',
      'rentabilidad', 'margen', 'utilidad', 'ganancia neta'
    ],

    LOTES_CAMPOS: [
      'lote', 'lotes', 'campo', 'campos', 'hectarea', 'hect√°rea', 'hectareas', 'hect√°reas',
      'superficie', 'terreno', 'terrenos', 'parcela', 'parcelas',
      'cultivo', 'cultivos', 'siembra', 'cosecha', 'zafra', 'tch'
    ],

    MAQUINARIA: [
      'maquina', 'm√°quina', 'maquinas', 'm√°quinas', 'tractor', 'tractores', 'cosechadora', 'cosechadoras',
      'implemento', 'implementos', 'equipo', 'equipos', 'service', 'mantenimiento',
      'combustible maquina', 'horas trabajadas', 'reparacion', 'reparaci√≥n'
    ],

    CHEQUES: [
      'cheque', 'cheques', 'vencimiento', 'vencimientos', 'vence', 'vencen',
      'al dia', 'al d√≠a', 'pendiente', 'pendientes', 'deposito', 'dep√≥sito'
    ]
  }

  // üîç T√çTULO: Funci√≥n para buscar coincidencias
  const buscarCoincidencias = (categoria: string[], texto: string): number => {
    let puntuacion = 0

    categoria.forEach(palabra => {
      // Buscar palabra exacta
      if (texto.includes(palabra)) {
        puntuacion += 2
      }

      // Buscar palabras similares (para captar variaciones)
      const palabras = texto.split(' ')
      palabras.forEach(p => {
        if (p.includes(palabra.substring(0, 4)) || palabra.includes(p.substring(0, 4))) {
          if (p.length > 3 && palabra.length > 3) {
            puntuacion += 1
          }
        }
      })
    })

    return puntuacion
  }

  // üéØ T√çTULO: Evaluar cada categor√≠a
  const resultados = {
    FINANCIERO_VENTAS: buscarCoincidencias(categorias.FINANCIERO_VENTAS, mensajeNormalizado),
    FINANCIERO_COMPRAS: buscarCoincidencias(categorias.FINANCIERO_COMPRAS, mensajeNormalizado),
    FINANCIERO_GENERAL: buscarCoincidencias(categorias.FINANCIERO_GENERAL, mensajeNormalizado),
    LOTES_CAMPOS: buscarCoincidencias(categorias.LOTES_CAMPOS, mensajeNormalizado),
    MAQUINARIA: buscarCoincidencias(categorias.MAQUINARIA, mensajeNormalizado),
    CHEQUES: buscarCoincidencias(categorias.CHEQUES, mensajeNormalizado)
  }

  // üèÜ T√çTULO: Encontrar la categor√≠a con mayor puntuaci√≥n
  const categoriaDetectada = Object.entries(resultados)
    .sort(([, a], [, b]) => b - a)[0]

  const [categoria, puntuacion] = categoriaDetectada

  // ‚úÖ T√çTULO: Solo devolver resultado si hay confianza m√≠nima
  if (puntuacion >= 2) {
    return {
      categoria: categoria,
      confianza: puntuacion,
      esFinanciero: categoria.startsWith('FINANCIERO'),
      subtipo: categoria.includes('VENTAS') ? 'ventas' :
        categoria.includes('COMPRAS') ? 'compras' : 'general'
    }
  }

  return {
    categoria: 'GENERAL',
    confianza: 0,
    esFinanciero: false,
    subtipo: 'general'
  }
}

// üåê T√çTULO: API ENDPOINT PRINCIPAL - MANEJA TODAS LAS CONSULTAS (FUNCI√ìN ORIGINAL COMPLETA)
export async function POST(request: NextRequest) {
  try {
    console.log('üì® Nueva consulta recibida...')
    
    // üì• T√çTULO: RECIBIR Y VALIDAR LA CONSULTA DEL USUARIO
    const { message, userId = 'usuario_default' } = await request.json()
    console.log('üí¨ Nueva consulta:', message)

// üß† VERIFICAR APRENDIZAJE
//const palabraDesconocida = await verificarPalabrasDesconocidas(message, 'emp_001')
//if (palabraDesconocida) {
//return NextResponse.json({
//// ... resto del c√≥digo  
//})
//}

//üéØ ¬øHACEMOS ESTE CAMBIO QUIR√öRGICO?
//Solo necesit√°s comentar 8 l√≠neas (750-757) y mantienes todas las 900+ l√≠neas con toda la funcionalidad avanzada.
//¬øComentamos esas l√≠neas problem√°ticas para que funcione inmediatamente?
//Es un cambio de 30 segundos que preserva TODO tu trabajo. üí™ReintentarClaude puede cometer errores. Verifique las respuestas.

    if (!message) {
      console.log('‚ùå Consulta vac√≠a rechazada')
      return NextResponse.json({ error: 'Mensaje requerido' }, { status: 400 })
    }

    console.log(`üë§ Usuario: ${userId} | üí¨ Consulta: "${message}"`)

    // üß† T√çTULO: OBTENER MEMORIA DE CONVERSACIONES ANTERIORES
    const conversationContext = ConversationMemoryManager.getConversationContext(userId)
    const currentContext = ConversationMemoryManager.detectContext(message)

    console.log(`üí≠ Contexto actual: ${currentContext}`)
    console.log(`üß† Memoria previa: ${conversationContext}`)

    // üéØ T√çTULO: Clasificar consulta inteligentemente
    const clasificacion = clasificarConsultaConMemoria(message, conversationContext)
    console.log(`üß† Consulta clasificada como: ${clasificacion.categoria} (confianza: ${clasificacion.confianza})`)

    // üìä T√çTULO: CONTEXTO BASE SIEMPRE
    const contextoEmpresa = await obtenerContextoEmpresa()

    // üéØ T√çTULO: CONTEXTO ESPEC√çFICO SEG√öN CONSULTA (MEJORADO)
    let contextoEspecifico = ''

    if (clasificacion.categoria === 'LOTES_CAMPOS') {
      // Si pregunta por lotes espec√≠ficos, agregar detalles
      const mensajeLower = message.toLowerCase()
      // üîß T√çTULO: DETECTORES MEJORADOS PARA DETALLES
      if (mensajeLower.includes('nombre') || mensajeLower.includes('detalle') || 
          mensajeLower.includes('cada') || mensajeLower.includes('cuales') ||
          mensajeLower.includes('listado') || mensajeLower.includes('dame') ||
          mensajeLower.includes('especifico') || mensajeLower.includes('todos')) {
        console.log('üîç Consultando detalles espec√≠ficos de lotes...')
        const lotesDetallados = await obtenerLotesDetallados()
        contextoEspecifico = `

üìã DETALLES ESPEC√çFICOS DE LOTES:
${lotesDetallados}`
      }
    }

    if (clasificacion.categoria === 'MAQUINARIA') {
      // Si pregunta por m√°quinas espec√≠ficas, agregar detalles
      const mensajeLower = message.toLowerCase()
      
      if (mensajeLower.includes('listado') || mensajeLower.includes('dame') ||
          mensajeLower.includes('detalle') || mensajeLower.includes('cuales') ||
          mensajeLower.includes('todos') || mensajeLower.includes('especifico') ||
          mensajeLower.includes('pasame') || mensajeLower.includes('mostrame') ||
          (clasificacion.esContextual && clasificacion.temaAnterior === 'maquinas')) {
        console.log('üöú Consultando listado detallado de m√°quinas...')
        const maquinasDetalladas = await obtenerListadoMaquinas()
        contextoEspecifico = `

üöú LISTADO ESPEC√çFICO DE M√ÅQUINAS:
${maquinasDetalladas}`
      }
    }


    // üí∞ T√çTULO: CONTEXTO FINANCIERO
    const esConsultaFinanciera = clasificacion.esFinanciero
    console.log('üß† Usando clasificaci√≥n inteligente:', clasificacion.categoria)
    // üß† T√çTULO: DETECTAR REFERENCIAS CONTEXTUALES
console.log(`üß† Clasificaci√≥n: ${clasificacion.categoria}, Contextual: ${clasificacion.esContextual}, Tema anterior: ${clasificacion.temaAnterior}`)

        let contextoFinanciero = ''
    if (esConsultaFinanciera) {
      const datosFinancieros = await obtenerDatosFinancieros()
      contextoFinanciero = `

üí∞ AN√ÅLISIS FINANCIERO DETALLADO:
${datosFinancieros.modoEmergencia ? 'üö® MODO EMERGENCIA - Datos estimados' : 'üìä DATOS EN TIEMPO REAL'}

üìÖ MES ACTUAL (${datosFinancieros.mes.nombre}):
- Ingresos: $${(datosFinancieros.mes.ingresos / 1000000).toFixed(1)}M (${datosFinancieros.mes.cantidadTransacciones} transacciones)
- Egresos: $${(datosFinancieros.mes.egresos / 1000000).toFixed(1)}M
- Flujo neto: $${(datosFinancieros.mes.flujoNeto / 1000000).toFixed(1)}M
- Margen: ${datosFinancieros.mes.margenPorcentaje.toFixed(1)}%
- Promedio por venta: $${(datosFinancieros.mes.promedioIngresoPorTransaccion / 1000).toFixed(0)}K

üí≥ CARTERA DE CHEQUES (${datosFinancieros.cheques.total} total):
- Valor total: $${(datosFinancieros.cheques.valorTotalCartera / 1000000).toFixed(1)}M
- Al d√≠a: ${datosFinancieros.cheques.porEstado['al_dia']?.cantidad || 0} cheques ($${((datosFinancieros.cheques.porEstado['al_dia']?.valor || 0) / 1000000).toFixed(1)}M)
- Pendientes: ${datosFinancieros.cheques.porEstado['pendiente']?.cantidad || 0} cheques ($${((datosFinancieros.cheques.porEstado['pendiente']?.valor || 0) / 1000000).toFixed(1)}M)
- Pr√≥ximos a vencer: ${datosFinancieros.cheques.proximosVencer.length} cheques

üè≠ LIQUIDACIONES INGENIOS:
- √öltima: ${datosFinancieros.liquidaciones.recientes[0]?.ingenioNombre || 'N/A'} - $${((datosFinancieros.liquidaciones.recientes[0]?.totalNeto || 0) / 1000000).toFixed(1)}M
- Total toneladas: ${datosFinancieros.liquidaciones.totalToneladas} tn
- Total facturado: $${(datosFinancieros.liquidaciones.totalFacturado / 1000000).toFixed(1)}M

üìä TOP GASTOS ESTE MES:
${datosFinancieros.categorias.topGastos.slice(0, 3).map(cat =>
  `- ${cat.categoria}: $${((cat._sum.importe || 0) / 1000).toFixed(0)}K`
).join('\n')}

üìà ACUMULADO A√ëO:
- Total transacciones: ${datosFinancieros.ano.transaccionesTotales}
- Monto total: $${(datosFinancieros.ano.montoTotal / 1000000).toFixed(1)}M`
    }

    // ü§ñ T√çTULO: GENERAR RESPUESTA CON INTELIGENCIA ARTIFICIAL
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: `Eres CeoBot, el CEO Digital de La Ramada S.A. con personalidad humana.


ü§ñ TU PERSONALIDAD √öNICA:
- Sos un CEO super amigable y accesible üòä
- Habl√°s como un amigo experto que conoce TODO el negocio
- Siempre positivo, proactivo y conversacional
- Us√°s emojis estrat√©gicamente para ser m√°s humano
- Das respuestas CORTAS y al grano, no textos largos
- Siempre ofrec√©s 1-2 sugerencias √∫tiles

üö® REGLA CR√çTICA - NUNCA INVENTAR DATOS:
- Si los datos muestran $0 o no existen, dec√≠ que NO TEN√âS esa informaci√≥n
- NUNCA inventes n√∫meros o montos que no est√°n en los datos reales
- Si pregunta por un mes/a√±o sin datos, responde: "No tengo registros de [per√≠odo]"
- S√â HONESTO sobre qu√© informaci√≥n ten√©s y cu√°l no

üìä MANEJO DE DATOS FALTANTES:
EJEMPLO CORRECTO:
Usuario: "¬øY junio?"
Si junio = $0: "No tengo registros de ventas para junio en el sistema üìä"
Si junio = $43M: "En junio vendimos $43M. ¬°Buen mes! üöÄ"

EJEMPLO INCORRECTO:
Usuario: "¬øY junio?" 
NO digas: "En junio vendimos $25M" (si los datos reales muestran $0)

üéØ ESTILO DE RESPUESTA:
üéØ ESTILO DE RESPUESTA:
1. SALUDO amigable cuando corresponda
2. RESPUESTA directa y clara (m√°ximo 3-4 l√≠neas)
3. SUGERENCIAS proactivas (1-2 opciones)
4. PREGUNTA de seguimiento para mantener la conversaci√≥n

üìù EJEMPLOS DE TU ESTILO:

CONSULTA: "¬øCu√°nto vendimos?"
TU RESPUESTA: "¬°Hola! üòä En julio vendimos $8.2M. ¬°Muy buen mes!
¬øTe gustar√≠a que lo compare con el a√±o pasado? ¬øO prefieres ver qu√© productos vendieron m√°s? üìä"

CONSULTA: "¬øY el a√±o pasado?"
TU RESPUESTA: "Julio 2024 vendimos $6.8M. ¬°Creciste 20%! üöÄ
¬øQuer√©s que analice qu√© impuls√≥ ese crecimiento? ¬øO revisamos mes por mes?"

üö´ NUNCA HAGAS:
- Respuestas largas y corporativas
- Usar lenguaje t√©cnico excesivo
- Dar solo datos sin contexto humano
- Olvidar ser proactivo con sugerencias

üß† SISTEMA DE APRENDIZAJE:
- Si encontr√°s palabras que no reconoc√©s, pregunt√° amigablemente qu√© significan
- Us√° frases como "ü§î No conozco esa palabra" o "¬øTe refer√≠s a...?"
- Siempre promet√© que "si me ense√±√°s, la pr√≥xima vez no te voy a preguntar"
- Cuando aprendas algo nuevo, confirm√°: "üéâ ¬°Perfecto! Ya aprend√≠ que [palabra] = [definici√≥n]"

EJEMPLO DE APRENDIZAJE:
CONSULTA: "¬øCu√°ntos alzaprimas tengo?"
TU RESPUESTA: "ü§î No conozco 'alzaprimas'. ¬øTe refer√≠s a alg√∫n tipo de maquinaria? Si me ense√±√°s, la pr√≥xima vez no te voy a preguntar. üòä"

üß† MEMORIA CONVERSACIONAL:
${conversationContext}

üåæ CONTEXTO AGROPECUARIO:
- Terminolog√≠a: TCH, zafra, hect√°reas, ingenio, cosecha
- Enfoque: Siempre en resultados y rentabilidad

DATOS ACTUALES DE LA EMPRESA:
${contextoEmpresa}

${contextoEspecifico}
${contextoFinanciero}

üéØ INSTRUCCI√ìN FINAL:
Respond√© como un CEO amigable que realmente se preocupa por ayudar. 
S√© conversacional, √∫til y siempre ofrec√© pr√≥ximos pasos.

CONTEXTO ACTUAL DE LA PREGUNTA: ${currentContext}`
        },
        {
          role: "user",
          content: message
        }
      ],
      max_tokens: 500,     // L√≠mite de respuesta para mantenerla concisa
      temperature: 0.7,    // Balance entre creatividad y precisi√≥n
    })

    // üì§ T√çTULO: PROCESAR Y GUARDAR LA RESPUESTA
    const respuesta = completion.choices[0]?.message?.content || "Disculp√°, no pude procesar tu consulta."

    // üíæ T√çTULO: GUARDAR CONVERSACI√ìN EN MEMORIA PARA PR√ìXIMAS CONSULTAS
    ConversationMemoryManager.saveInteraction(
      userId,
      message,
      respuesta,
      currentContext
    )

    console.log('‚úÖ Respuesta generada y guardada exitosamente')

    // üöÄ T√çTULO: ENVIAR RESPUESTA AL USUARIO
    return NextResponse.json({
      message: respuesta,
      timestamp: new Date().toISOString(),
      context: currentContext,
      userId: userId
    })

    } catch (error) {
    console.error('üí• Error cr√≠tico en chat API:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
}
}